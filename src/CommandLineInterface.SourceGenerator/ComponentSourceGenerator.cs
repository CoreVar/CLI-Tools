using CoreVar.CommandLineInterface.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace CoreVar.CommandLineInterface.SourceGenerator;

[Generator]
public partial class ComponentSourceGenerator : IIncrementalGenerator
{
    
    private string CompilerSafeString(string value)
    {
        var builder = new StringBuilder("\"", value.Length + 2);
        foreach (var valueChar in value)
            builder.Append(valueChar switch
            {
                '"' => "\\\"",
                '\n' => "\\\n",
                '\r' => "\\\r",
                '\t' => "\\\t",
                _ => valueChar
            });
        builder.Append("\"");
        return builder.ToString();
    }

    private string CompilerSafeVariableName(string value)
    {
        var builder = new StringBuilder(value.Length);
        foreach (var valueChar in value)
        {
            if (!char.IsLetterOrDigit(valueChar))
                continue;
            builder.Append(valueChar);
        }
        if (char.IsDigit(builder[0]))
            builder.Insert(0, '_');
        return builder.ToString();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        Debugger.Log(1, "Sourcegen", "Initializing");

#if DEBUG
        //if (!Debugger.IsAttached)
        //    Debugger.Launch();
#endif


        var knownTypeSymbols = context.CompilationProvider.Select((compilation, _) => new KnownTypeSymbols(compilation));

        var contextGenerationSpecs = context.SyntaxProvider.ForAttributeWithMetadataName(
            Parser.ComponentAttributeFullName,
            (node, _) =>
            {
                return node is ClassDeclarationSyntax;
            },
            (context, _) => (ContextClass: (ClassDeclarationSyntax)context.TargetNode, context.SemanticModel))
            .Combine(knownTypeSymbols)
            .Select(static (tuple, cancellationToken) =>
            {
                var parser = new Parser(tuple.Right);
                var contextSpec = parser.ParseComponentContext(tuple.Left.ContextClass, tuple.Left.SemanticModel, cancellationToken);
                return contextSpec;
            });

        context.RegisterSourceOutput(contextGenerationSpecs, EmitSource);
    }

    private void EmitSource(SourceProductionContext context, object? source)
    {
        if (source is not ComponentContextSpec componentContextSpec)
            return;
#if DEBUG
        //if (!Debugger.IsAttached)
        //    Debugger.Launch();
#endif

        var sourceBuilder = new StringBuilder();
        var indent = 0;
        sourceBuilder.Append($@"// <auto-generated/>
using CoreVar.CommandLineInterface;
using CoreVar.CommandLineInterface.Builders;
using CoreVar.CommandLineInterface.Support;
using CoreVar.CommandLineInterface.Builders.Internals;
using Microsoft.Extensions.DependencyInjection;

");
        var typeNamespace = componentContextSpec.Type.ContainingNamespace.Name;
        var typeName = componentContextSpec.Type.Name;

        sourceBuilder.AppendLine($@"namespace {typeNamespace};");

        sourceBuilder.Append($@"
{new string(' ', indent * 4)}partial class {typeName}
{new string(' ', indent * 4)}{{");
        indent++;

        sourceBuilder.Append($@"
{new string(' ', indent * 4)}public static {typeName} Default {{ get; }} = new();

{new string(' ', indent * 4)}protected override void Build(IExecutableBuilder builder)
{new string(' ', indent * 4)}{{
");
        indent++;

        foreach (var componentIdentifier in componentContextSpec.Components)
        {
            var componentPropertyName = componentIdentifier.Type.Name;
            if (componentPropertyName.EndsWith("Component"))
                componentPropertyName = componentPropertyName.Substring(0, componentPropertyName.Length - 9);

            sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}((ISourceGeneratedComponentInternals){componentPropertyName}).Build(builder);");
        }

        // End of function
        indent--;
        sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}}}");

        // Properties
        foreach (var componentSpec in componentContextSpec.Components)
        {
            EmitComponent(context, sourceBuilder, "builder", componentSpec, indent);
        }

        // End of class
        indent--;
        sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}}}");

        var sourceCode = sourceBuilder.ToString();
        context.AddSource($"{typeName}.g.cs", sourceCode);
    }

    private void EmitComponent(SourceProductionContext context, StringBuilder sourceBuilder, string builderVariableName, ComponentSpec componentSpec, int indent)
    {
        var staticPropertyName = componentSpec.Type.Name;
        if (staticPropertyName.EndsWith("Component"))
            staticPropertyName = staticPropertyName.Substring(0, staticPropertyName.Length - 9);

        sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}public SourceGeneratedComponentReference<{componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> {staticPropertyName} {{ get; }} = new SourceGeneratedComponentReference<{componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(builder =>
{new string(' ', indent * 4)}{{");
        indent++;

        EmitComponentBuilder(context, sourceBuilder, builderVariableName, componentSpec, indent);

        indent--;
        sourceBuilder.Append(@$"{new string(' ', indent * 4)}}});
");
    }


    private void EmitComponentBuilder(SourceProductionContext context, StringBuilder sourceBuilder, string builderVariableName, ComponentSpec componentSpec, int indent)
    {
        var commandParameterName = $"{CompilerSafeVariableName(componentSpec.Name)}Command";
        var generatedCommandName = componentSpec.Name.Replace("\"", "\\\"");

        sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}{builderVariableName}.Command(""{generatedCommandName}"", {commandParameterName} =>
{new string(' ', indent * 4)}{{");

        indent++;

        var hasSetup =
            componentSpec.SetupHostBuilderMethodName is not null ||
            componentSpec.SetupServicesMethodName is not null ||
            componentSpec.SetupHostMethodName is not null;
        if (hasSetup)
        {
            sourceBuilder.Append($@"{new string(' ', indent * 4)}{commandParameterName}");
            indent++;
        }

        if (componentSpec.SetupHostBuilderMethodName is not null)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.Append($@"{new string(' ', indent * 4)}.SetupHostBuilder({componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{componentSpec.SetupHostBuilderMethodName})");
        }

        if (componentSpec.SetupServicesMethodName is not null)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.Append($@"{new string(' ', indent * 4)}.SetupHostBuilder(builder => {componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{componentSpec.SetupServicesMethodName}(builder.Services))");
        }

        if (componentSpec.SetupHostMethodName is not null)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.Append($@"{new string(' ', indent * 4)}.SetupHost({componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{componentSpec.SetupHostMethodName})");
        }

        if (hasSetup)
        {
            sourceBuilder.AppendLine(";");
            indent--;
        }


        var propertyAssignmentsBuilder = new StringBuilder();

        foreach (var argument in componentSpec.Arguments)
        {
            var argumentParameterName = $"{CompilerSafeVariableName(argument.Name)}Argument";

            sourceBuilder.Append($@"{new string(' ', indent * 4)}var {argumentParameterName} = {commandParameterName}.Argument<{argument.TargetPropertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>({CompilerSafeString(argument.Name)})");
            indent++;

            if (argument.Description is not null)
            {
                sourceBuilder.AppendLine();
                sourceBuilder.Append($@"{new string(' ', indent * 4)}.Description({CompilerSafeString(argument.Description)})");
            }

            indent--;
            sourceBuilder.AppendLine(";");


            indent += 2;
            propertyAssignmentsBuilder.AppendLine($@"{new string(' ', indent * 4)}component.{argument.TargetPropertyName} = context.GetArgument({argumentParameterName});");
            indent -= 2;
        }

        foreach (var option in componentSpec.Options)
        {
            var optionParameterName = $"{CompilerSafeVariableName(option.Name)}Option";

#if DEBUG
            //if (!Debugger.IsAttached)
            //    Debugger.Launch();
#endif
            if (option.TargetPropertyType.Name == "Boolean" && option.TargetPropertyType.ContainingNamespace.Name == "System")
                sourceBuilder.Append($@"{new string(' ', indent * 4)}var {optionParameterName} = {commandParameterName}.Option({CompilerSafeString(option.Name)})");
            else
                sourceBuilder.Append($@"{new string(' ', indent * 4)}var {optionParameterName} = {commandParameterName}.Option<{option.TargetPropertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>({CompilerSafeString(option.Name)})");
            indent++;

            if (option.Description is not null)
            {
                sourceBuilder.AppendLine();
                sourceBuilder.Append($@"{new string(' ', indent * 4)}.Description({CompilerSafeString(option.Description)})");
            }

            indent--;
            sourceBuilder.AppendLine(";");


            indent += 2;
            propertyAssignmentsBuilder.AppendLine($@"{new string(' ', indent * 4)}component.{option.TargetPropertyName} = context.GetOption({optionParameterName});");
            indent -= 2;
        }

        var hasElement = componentSpec.Description is not null ||
            componentSpec.ExecuteMethodName is not null; ;

        if (hasElement)
            sourceBuilder.Append($@"{new string(' ', indent * 4)}{commandParameterName}");

        indent++;

        if (componentSpec.Description is not null)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.Append($@"{new string(' ', indent * 4)}.Description({CompilerSafeString(componentSpec.Description)})");
        }

        // On Execute
        if (componentSpec.ExecuteMethodName is not null)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}.OnExecute(async context =>
{new string(' ', indent * 4)}{{");

            indent++;
            sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}var component = ActivatorUtilities.CreateInstance<{componentSpec.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(context.Services);
{new string(' ', indent * 4)}((ICommandLineComponentInternals)component).Initialize(context);");

            sourceBuilder.Append(propertyAssignmentsBuilder);

            sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}await component.{componentSpec.ExecuteMethodName}();
{new string(' ', indent * 4)}if (component is IAsyncDisposable asyncDisposable)
{new string(' ', (indent + 1) * 4)}await asyncDisposable.DisposeAsync();
{new string(' ', indent * 4)}if (component is IDisposable disposable)
{new string(' ', (indent + 1) * 4)}disposable.Dispose();");

            indent--;
            sourceBuilder.Append($@"{new string(' ', indent * 4)}}})");
        }
        if (hasElement)
            sourceBuilder.AppendLine(";");

        indent--;

        foreach (var nestedCommand in componentSpec.NestedCommands)
        {
            EmitComponentBuilder(context, sourceBuilder, commandParameterName, nestedCommand, indent);
        }

        indent--;
        sourceBuilder.AppendLine($@"{new string(' ', indent * 4)}}});");
    }

}
